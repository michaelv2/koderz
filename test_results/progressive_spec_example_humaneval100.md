# Progressive Spec Disclosure: HumanEval/100 Example

**Problem**: `make_a_pile(n)` - Create a pile of n levels with incrementing stone counts

---

## Phase 1: Initial Minimal Spec

**Generated by**: gpt-oss:20b (local, $0)
**Length**: 720 chars
**Time**: ~18s

```
Problem analysis
The task is to produce a sequence of stone counts for a pile with exactly `n` levels.
- The first level contains `n` stones.
- Every subsequent level must have the same parity (odd or even) as the first level.
- The number of stones increases by 2 from one level to the next.
The input is a single positive integer `n`; the output is a list of `n` integers
representing the stone counts of each level.

Implementation specification
`make_a_pile(n)`
- Input: a positive integer `n`.
- Output: a list of length `n`.
  - The element at index `i` (0‑based) equals `n + 2*i`.
  - Thus the list starts with `n` and each following element is 2 greater than
    the previous one.
```

**What the local model knows**:
- ✓ Problem structure (n levels, incrementing by 2)
- ✓ Output format (list of n integers)
- ✓ Basic formula (n + 2*i)
- ✗ NO algorithm hints
- ✗ NO edge cases
- ✗ NO test criteria
- ✗ NO code examples

---

## Iterations 1-5: Local Model Struggles

**Model**: qwen2.5-coder:32b (local, $0)
**Pass rate**: 0% → 20% (stuck)

**Common mistakes**:
1. Adding `i` instead of `2*i` → `[3, 4, 5]` instead of `[3, 5, 7]`
2. Conditional logic based on parity → `if n % 2 == 0: ... else: ...`
3. Wrong branch applying `*2` → odd gets `+i`, even gets `+2*i` (backwards)
4. Reaching 20% pass rate but stuck in plateau

---

## Checkpoint 1 (Iteration 5): Strategic Guidance

**Generated by**: Claude Sonnet 4.5 (frontier, $0.0255)
**Length**: 2,388 chars
**Combines**: 4-section debugging + strategic guidance

### Debugging Analysis (Current behavior)

```
1. FAILING TEST ANALYSIS
   - Pass rate: 20% (1/5 tests)
   - Error: AssertionError: assert [4, 5, 6, 7] == [4, 6, 8, 10]
   - Model applying wrong increment to wrong parity

2. ROOT CAUSE DIAGNOSIS
   - Line: return [n + i*2 if n % 2 == 1 else n + i for i in range(n)]
   - When n=4 (even), using n + i instead of n + 2*i
   - Conditional logic is backwards

3. PROPOSED FIX
   - Remove conditional entirely
   - Use: return [n + i*2 for i in range(n)]
   - Both odd and even sequences increment by 2!

4. EDGE CASES TO VERIFY
   - n=1: [1] (single element)
   - n=2: [2, 4] (even sequence)
   - n=5: [5, 7, 9, 11, 13] (longer odd)
```

### + Progressive Spec Section (NEW)

```
STRATEGIC GUIDANCE FROM SENIOR DEVELOPER:

## Implementation Approach
The problem requires generating an arithmetic sequence with a common difference of 2.
The starting value is `n`, and you need exactly `n` terms. The key insight:
- Both odd and even starting values follow the SAME pattern: increment by 2 each time
- The parity (odd/even) is determined by the starting value `n`, not by branching logic
- This is a simple arithmetic progression: [n, n+2, n+4, n+6, ...] for n terms

The failed attempts reveal a misconception: the model kept trying to apply different
logic for odd vs. even `n`, when in reality the increment pattern is identical—only
the starting point differs.

## Edge Cases to Handle
- n = 1: Single element list containing just [n]
- Small even numbers (n=2, 4): Must produce even sequences [2,4], [4,6,8,10]
- Small odd numbers (n=3, 5): Must produce odd sequences [3,5,7], [5,7,9,11,13]
- Verify the list length equals n (not n-1 or n+1)

## Common Pitfalls
1. Over-complicating with conditionals: Both branches need the same increment logic
2. Confusing increment amount with index: Using `i` instead of `i*2` causes +1 not +2
3. Backwards conditional logic: Applying `*2` to the wrong branch (odd vs even)
4. Off-by-one in range: Must use range(n) to get exactly n elements, not range(n-1)
```

**Key insight provided**: "Both odd and even sequences follow the same pattern!"

---

## Iterations 6-10: Improved but Stuck

**Model**: qwen2.5-coder:32b (local, $0)
**Pass rate**: 80% (stuck in plateau for 5 iterations)

**After Checkpoint 1**:
- ✓ Fixed core logic: `return [n + 2*i for i in range(n)]`
- ✓ Improved from 20% → 80%
- ✗ Still failing 1 specific test case
- ✗ Unknown edge case causing failure

---

## Checkpoint 2 (Iteration 10): Test Criteria

**Generated by**: Claude Sonnet 4.5 (frontier, $0.0255)
**Length**: 2,223 chars
**Combines**: 4-section debugging + test-focused guidance

### Debugging Analysis (Current behavior)

```
1. FAILING TEST ANALYSIS
   - Pass rate: 80% (4/5 tests) - PLATEAU for 5 iterations
   - One specific test case consistently failing
   - Core logic appears correct

2. ROOT CAUSE DIAGNOSIS
   - Code: return [n + 2*i for i in range(n)]
   - Logic is mathematically correct
   - Likely an edge case not being handled

3. PROPOSED FIX
   - Add explicit edge case handling:
     if n <= 0: return []
   - Alternative approach using range:
     return list(range(n, n + 2*n, 2))

4. EDGE CASES TO VERIFY
   - n = 0 or negative values
   - n = 1 (minimum valid)
   - n = 100 (large values)
```

### + Progressive Spec Section (NEW)

```
TEST CRITERIA FROM SENIOR DEVELOPER:

## Test Criteria & Expected Behavior

### Normal Cases:
# Odd starting value
assert make_a_pile(3) == [3, 5, 7]
assert make_a_pile(1) == [1]
assert make_a_pile(5) == [5, 7, 9, 11, 13]

# Even starting value
assert make_a_pile(2) == [2, 4]
assert make_a_pile(4) == [4, 6, 8, 10]
assert make_a_pile(6) == [6, 8, 10, 12, 14, 16]

### Edge Cases:
# Minimum valid input
assert make_a_pile(1) == [1]

# Large values
assert make_a_pile(100) == [100, 102, 104, ..., 298]  # 100 elements
assert len(make_a_pile(100)) == 100
assert make_a_pile(100)[0] == 100
assert make_a_pile(100)[-1] == 298

### Critical verification:
- Length check: len(make_a_pile(n)) == n for all n > 0
- First element: make_a_pile(n)[0] == n
- Last element: make_a_pile(n)[-1] == n + 2*(n-1)
- Parity maintained: All elements odd if n is odd, all even if n is even
- Increment of 2: make_a_pile(n)[i+1] - make_a_pile(n)[i] == 2 for all valid i
```

**Key insight provided**: Specific test cases showing expected inputs/outputs

---

## Summary: Progressive Disclosure in Action

### Cost Breakdown (10 iterations to 80% pass rate)
- Initial spec: gpt-oss:20b - $0.00
- Iterations 1-5: qwen2.5-coder:32b - $0.00
- Checkpoint 1: Claude Sonnet 4.5 - $0.0255
- Iterations 6-10: qwen2.5-coder:32b - $0.00
- Checkpoint 2: Claude Sonnet 4.5 - $0.0255

**Total cost**: $0.051

### What the Local Model Received

**After initial spec** (iteration 0):
- Problem description
- Basic formula

**After Checkpoint 1** (iteration 5):
- All of the above
- + "Both odd and even follow same pattern" insight
- + Common pitfalls to avoid
- + Strategic approach (arithmetic sequence)

**After Checkpoint 2** (iteration 10):
- All of the above
- + Specific test cases with expected outputs
- + Edge case specifications
- + Verification criteria

### Adaptive vs. Static Comparison

**What makes this "adaptive"**:
- ✓ Checkpoint 1 analyzed actual failures → identified "conditional logic" misconception
- ✓ Checkpoint 2 detected plateau → suggested alternative approaches
- ✓ Strategic guidance targeted to observed struggles (not generic)
- ✓ Test cases chosen based on failure patterns

**If this were static** (pre-generated):
- ✗ Would provide generic edge cases regardless of failures
- ✗ Wouldn't detect the "conditional logic" misconception
- ✗ Wouldn't recognize plateau and suggest alternatives
- ✗ Test cases wouldn't be failure-driven

---

## Comparison: Direct Frontier Solve

**Alternative**: Just use Claude Sonnet 4.5 from the start

**Cost**: ~$0.005 (one API call, ~500 tokens)
**Result**: Correct solution immediately

**Tradeoff**:
- Iterative approach: $0.051 (10x more expensive)
- Learning value: Local model gets strategic guidance
- Architecture research: Tests adaptive escalation

This only makes economic sense if:
1. Most problems succeed without checkpoints (<$0.01 avg cost)
2. The system builds long-term local model capability
3. Research value justifies the cost overhead
