To solve the problem of finding the minimum number of elements that need to be changed to make an array palindromic, we can use a two-pointer approach. This involves comparing elements from the start and end of the array moving towards the center. If the elements at these positions are not equal, one of them needs to be changed to make them equal. We count such changes as they are necessary.

Here's the implementation:

```python
def smallest_change(arr):
    left = 0
    right = len(arr) - 1
    changes = 0
    
    while left < right:
        if arr[left] != arr[right]:
            changes += 1
        left += 1
        right -= 1
    
    return changes
```

### Explanation:
1. **Initialization**: We initialize two pointers, `left` starting at the beginning of the array and `right` starting at the end.
2. **Counting Changes**: We iterate while `left` is less than `right`. If the elements at these positions are not equal, we increment the `changes` counter.
3. **Move Pointers**: We move the `left` pointer one step to the right and the `right` pointer one step to the left.
4. **Return Result**: Finally, we return the total number of changes required.

This approach ensures that we only make the necessary changes to convert the array into a palindromic one, with a time complexity of O(n), where n is the length of the array.