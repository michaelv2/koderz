Let me reason through this problem:

1. First, I need to generate an array where `a[i] = i*i - i + 1` for i from 1 to n
2. Then, I need to count triples (a[i], a[j], a[k]) where i < j < k and their sum is divisible by 3
3. Key insight: instead of checking all triples, I can use modular arithmetic. A sum is divisible by 3 if the sum of remainders (mod 3) equals 0 or 3 or 6, etc.

Let me think about the pattern of `i*i - i + 1` modulo 3:
- When i ≡ 0 (mod 3): i² - i + 1 ≡ 0 - 0 + 1 ≡ 1 (mod 3)
- When i ≡ 1 (mod 3): i² - i + 1 ≡ 1 - 1 + 1 ≡ 1 (mod 3)
- When i ≡ 2 (mod 3): i² - i + 1 ≡ 4 - 2 + 1 ≡ 1 - 2 + 1 ≡ 0 (mod 3)

So every element has remainder either 0 or 1 when divided by 3.

For a sum to be divisible by 3:
- (0 + 0 + 0) mod 3 = 0 ✓
- (1 + 1 + 1) mod 3 = 0 ✓
- (0 + 1 + 1) mod 3 = 2 ✗
- (0 + 0 + 1) mod 3 = 1 ✗

So we need either:
1. All three elements have remainder 0 mod 3, OR
2. All three elements have remainder 1 mod 3

Let me count how many elements fall into each category:
- Remainder 0: when i ≡ 2 (mod 3) → indices 2, 5, 8, ... (every third starting from 2)
- Remainder 1: when i ≡ 0 or 1 (mod 3) → all other indices

Then I can use combinations to count valid triples.

```python
def get_max_triples(n):
    from math import comb
    
    # Count elements with remainder 0 and 1 when divided by 3
    count_0 = 0  # elements where a[i] ≡ 0 (mod 3)
    count_1 = 0  # elements where a[i] ≡ 1 (mod 3)
    
    for i in range(1, n + 1):
        val = i * i - i + 1
        if val % 3 == 0:
            count_0 += 1
        else:
            count_1 += 1
    
    # Number of triples where all have remainder 0: C(count_0, 3)
    # Number of triples where all have remainder 1: C(count_1, 3)
    result = comb(count_0, 3) + comb(count_1, 3)
    
    return result
```