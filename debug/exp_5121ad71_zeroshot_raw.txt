Looking at this problem, I need to determine if an array can be sorted in non-decreasing order by performing right shift operations.

Let me think about what a right shift does:
- It moves all elements one position to the right
- The last element moves to the first position
- If I perform k right shifts, the array [a, b, c, d] becomes [d, a, b, c]

The key insight is that if an array can be sorted by right shifts, then there must exist some rotation point where if I split the array and swap the parts, I get a sorted array.

For example, [3, 4, 5, 1, 2] can be viewed as [1, 2] + [3, 4, 5] - if I rotate it to start from index 3, I get [1, 2, 3, 4, 5] which is sorted.

My approach:
1. Handle empty array case - return True
2. Find how many "breaks" exist in the array (where arr[i] > arr[i+1])
3. If there are 0 breaks, array is already sorted - return True
4. If there's exactly 1 break, check if rotating at that point gives a sorted array
5. If there are more than 1 break, return False

Wait, let me reconsider. The array can be sorted by right shifts if and only if it's a rotation of a sorted array. This means:
- There should be at most one "break point" where a larger element is followed by a smaller element
- If there's exactly one break point, the array should be sorted when we "rotate" it at that point

Let me trace through the examples:
- [3, 4, 5, 1, 2]: breaks at index 2 (5>1), so we can rotate at index 2 to get [1, 2, 3, 4, 5] - True
- [3, 5, 4, 1, 2]: breaks at index 1 (5>4) and index 2 (4>1), so more than one break - False

```python
def move_one_ball(arr):
    if not arr:
        return True
    
    n = len(arr)
    break_count = 0
    break_index = -1
    
    # Count breaks and find the index where break occurs
    for i in range(n):
        next_index = (i + 1) % n
        if arr[i] > arr[next_index]:
            break_count += 1
            break_index = i
    
    # If no breaks, array is already sorted
    if break_count == 0:
        return True
    
    # If more than one break, impossible to sort with rotations
    if break_count > 1:
        return False
    
    # If exactly one break, check if rotating at that point gives sorted array
    # The rotation point should be break_index + 1
    # Check if array from break_index + 1 to end + array from start to break_index is sorted
    rotated_arr = arr[break_index + 1:] + arr[:break_index + 1]
    
    # Check if rotated array is sorted
    for i in range(len(rotated_arr) - 1):
        if rotated_arr[i] > rotated_arr[i + 1]:
            return False
    
    return True
```