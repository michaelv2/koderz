Looking at this problem, I need to implement a function that finds a zero of a polynomial. The function `find_zero` takes a list of coefficients and returns a value `x` such that `poly(xs, x) = 0`.

Let me analyze what's given:
1. `poly(xs, x)` evaluates a polynomial at point x
2. `find_zero` should find where the polynomial equals zero
3. The polynomial has an even number of coefficients
4. The largest non-zero coefficient is the leading coefficient (which guarantees a solution)

Looking at the examples:
- For `[1, 2]`: f(x) = 1 + 2x, so 1 + 2x = 0 → x = -0.5
- For `[-6, 11, -6, 1]`: This represents (x-1)(x-2)(x-3) = -6 + 11x - 6x² + x³, so one zero is 1.0

Since we're guaranteed a solution and the problem mentions "only one zero point", I'll implement a simple approach using numerical methods. Given that we're dealing with polynomials, I'll use a simple root-finding method like bisection or Newton's method.

However, looking more carefully at the constraints and examples, this seems to be a problem where we can use the fact that we're dealing with polynomials of degree at most 3 (since we have 4 coefficients) and we can use a more direct approach.

For a linear polynomial (degree 1), we can solve directly.
For higher degrees, I'll use a numerical method.

But wait, let me re-read the problem. It says "find_zero only takes list xs having even number of coefficients and largest non zero coefficient as it guarantees a solution." This suggests we're dealing with polynomials that have a guaranteed solution.

Let me implement a solution using scipy's root finding or a simple numerical approach:

```python
import math
import numpy as np

def poly(xs: list, x: float):
    """
    Evaluates polynomial with coefficients xs at point x.
    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n
    """
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])

def find_zero(xs: list):
    """ xs are coefficients of a polynomial.
    find_zero find x such that poly(x) = 0.
    find_zero returns only only zero point, even if there are many.
    Moreover, find_zero only takes list xs having even number of coefficients
    and largest non zero coefficient as it guarantees
    a solution.
    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x
    -0.5
    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3
    1.0
    """
    # For linear polynomial (degree 1)
    if len(xs) == 2:
        # xs[0] + xs[1] * x = 0
        # x = -xs[0] / xs[1]
        return -xs[0] / xs[1]
    
    # For higher degree polynomials, use numerical method
    # We'll use numpy's roots function for simplicity
    # But since we can't use numpy, let's implement a simple approach
    
    # Try a simple bisection method or Newton-Raphson
    # Let's use a simple approach: try some values and see where sign changes
    
    # For a general polynomial, we can use a numerical root finder
    # Since we're guaranteed a solution, let's try a simple approach
    
    # Try Newton-Raphson method
    def newton_raphson(x0, max_iter=100, tol=1e-10):
        x = x0
        for _ in range(max_iter):
            fx = poly(xs, x)
            if abs(fx) < tol:
                return x
            # Compute derivative
            if len(xs) == 2:
                # Linear: derivative is xs[1]
                fpx = xs[1]
            else:
                # For general case, compute numerical derivative
                fpx = 0
                for i in range(1, len(xs)):
                    fpx += i * xs[i] * math.pow(x, i-1)
            
            if abs(fpx) < 1e-15:
                break
                
            x_new = x - fx / fpx
            if abs(x_new - x) < tol:
                return x_new
            x = x_new
        return x
    
    # Try different starting points
    candidates = [0, 1, -1, 2, -2, 0.5, -0.5, 10, -10]
    
    for start in candidates:
        try:
            root = newton_raphson(start)
            # Verify it's actually a root
            if abs(poly(xs, root)) < 1e-8:
                return root
        except:
            continue
    
    # If all else fails, return a default
    return 0.0
```