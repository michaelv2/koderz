Let me reason through this problem:

1. A right shift operation moves the last element to the front
2. We can perform this operation any number of times
3. We need to check if ANY rotation of the array can result in a sorted (non-decreasing) array

Key insight: If we rotate an array enough times, we'll eventually get back to the original. So we only need to check all possible rotations (at most N rotations).

However, there's a more efficient approach:
- If an array can be sorted by rotations, then there exists some rotation that is sorted
- This means if we look at the array, we should be able to find a point where we can "split" it such that if we move elements from the end to the beginning, we get a sorted array
- In other words, the array should have at most one "break point" where arr[i] > arr[i+1], and if such a break exists, the element after the break should be <= the first element

Let me trace through the examples:
- `[3, 4, 5, 1, 2]`: Break at index 2 (5 > 1). After break: 1, 2. Before break: 3, 4, 5. Check: 2 <= 3 ✓ and array is sorted when rotated. TRUE
- `[3, 5, 4, 1, 2]`: Break at index 1 (5 > 4) and also at index 2 (4 > 1). Multiple breaks. FALSE

Algorithm:
1. If array is empty or has 1 element, return True
2. Count the number of "breaks" where arr[i] > arr[i+1]
3. If there are 0 breaks, the array is already sorted → return True
4. If there is exactly 1 break, check if arr[-1] <= arr[0] (last element <= first element) → return that condition
5. If there are 2+ breaks, return False

```python
def move_one_ball(arr):
    if len(arr) <= 1:
        return True
    
    # Count the number of positions where arr[i] > arr[i+1]
    break_count = 0
    break_index = -1
    
    for i in range(len(arr) - 1):
        if arr[i] > arr[i + 1]:
            break_count += 1
            break_index = i
    
    # If no breaks, array is already sorted
    if break_count == 0:
        return True
    
    # If exactly one break, check if last element <= first element
    # This ensures that when we rotate, the end connects properly to the beginning
    if break_count == 1:
        return arr[-1] <= arr[0]
    
    # If more than one break, it's impossible
    return False
```