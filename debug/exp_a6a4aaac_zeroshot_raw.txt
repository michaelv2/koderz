Looking at this problem, I need to:

1. Parse a string with multiple groups of nested parentheses separated by spaces
2. For each group, calculate the maximum nesting depth
3. Return a list of these maximum depths

Let me trace through the example:
- `'(()()) ((())) () ((())()())'`
- First group `(()())`: levels are 1, 2, 2, 1, 1 → max = 2
- Second group `((()))`: levels are 1, 2, 3, 2, 1 → max = 3  
- Third group `()`: levels are 1, 0 → max = 1
- Fourth group `((())()())`: levels are 1, 2, 2, 1, 1, 1, 1 → max = 2

Wait, let me retrace the fourth group more carefully:
- `((())()())` 
- Position 0: `(` → depth = 1
- Position 1: `(` → depth = 2  
- Position 2: `(` → depth = 3
- Position 3: `)` → depth = 2
- Position 4: `(` → depth = 1
- Position 5: `)` → depth = 0
- Position 6: `(` → depth = 1
- Position 7: `)` → depth = 0
- Position 8: `(` → depth = 1
- Position 9: `)` → depth = 0

Actually, let me re-read the example. The expected output is [2, 3, 1, 3], so the fourth group should give 3.

Let me trace `((())()())` again:
- `(` → depth = 1
- `(` → depth = 2  
- `(` → depth = 3
- `)` → depth = 2
- `(` → depth = 1
- `)` → depth = 0
- `(` → depth = 1
- `)` → depth = 0
- `(` → depth = 1
- `)` → depth = 0

Max depth = 3. That matches.

My approach:
1. Split the string by spaces to get individual groups
2. For each group, iterate through characters and track current depth
3. Keep track of the maximum depth reached
4. Return list of maximum depths

```python
def parse_nested_parens(paren_string: str) -> List[int]:
    groups = paren_string.split()
    result = []
    
    for group in groups:
        max_depth = 0
        current_depth = 0
        
        for char in group:
            if char == '(':
                current_depth += 1
                max_depth = max(max_depth, current_depth)
            elif char == ')':
                current_depth -= 1
        
        result.append(max_depth)
    
    return result
```